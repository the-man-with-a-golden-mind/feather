#!usr/bin/perl

use strict;
use warnings;
use feature 'switch';
use feature qw(say);
use File::Path qw(rmtree);
use File::Spec;
use JSON::XS;
use File::Find::Rule;
use Cwd;
use Capture::Tiny qw(tee);
use Data::Dumper;
no warnings "experimental::smartmatch";

sub check_exists_command { 
    my $check = `sh -c 'command -v $_[0]'`; 
    return $check;
}

sub clean_feather {
  rmtree "./ol/";
  unlink("run.sh");
}

sub clean_ol {
  rmtree "./ol/samples";
  rmtree "./ol/tests";
  rmtree "./ol/tmp";
  rmtree "./ol/.git";
  rmtree "./ol/.github";
}


sub make_run_file {
  # @TODO: If I would even need to run it on windows.
  #my $sep = File::Spec->catfile('', '');
  my $shell = $ENV{SHELL};
  my $alias_file = "run.sh";
  #rlwrap is not recognizing aliases :/
  #my $rlwrap = length(check_exists_command("rlwrap")) > 0 ? "rlwrap" : "";
  open(my $fh, ">", $alias_file) or die "Could not creaate .alias file";
  my $content = "
    #!$shell
    alias ol=\"./ol/ol\"
    ol run.scm \$@ 
  ";

  print $fh $content;
  close $fh;
  system("chmod u+x run.sh");
  say("Run file has been created");
}

sub build_ol {
  say("I am trying to build Ol...");
  my $result = system("cd ./ol && make");
  if ($result == 0) {
    make_run_file();
    clean_ol();
  } else {
    say("Somethings has crashed. Check logs");
  }
}

sub download_ol {
  my $otus_link = "https://github.com/yuriy-chumak/ol";
  say("Downloading new Ol instance");
  system("git", "clone", "--depth=1", "--branch=master",  $otus_link);
  say("Ol has been downloaded");
}

sub update_ol {
  say("Updating existing instance of Ol");
  rmtree "./ol";
  download_ol();
  build_ol();
  }

sub create_run_file() {
  open(my $rf, ">", "run.scm");
  my $run_file_content = '
(define *path* (cons "./" (cons "./libs" *path*)))
(import (otus lisp))
(print "HELLO THERE")
  ';
  print $rf $run_file_content;
  close $rf;
}

sub create_feather_json_file() {
  my $file_content = '
{
  "name": "package_name",
  "author": "author_name",
  "license": "license_name",
  "deps": []
}
  ';
  open (my $fl, ">", "feather.json");
  print $fl $file_content;
  close $fl;
}

sub install_ol {
  say("Installing Ol...");
  if (-d "ol") {
    update_ol();
  } else {
    download_ol();
    build_ol();
  }
  if (not (-d "./libs")) {
    mkdir "./libs";
  }
  create_run_file();
  create_feather_json_file();
} 

sub print_help {
  my $help = "
      F E A T H E R
        Ol's VE

          (`/\\
          `=\\/\\
           `=\\/\\
            `=\\/
               \\

    Commands:
      init    -   to initialize your new project. It will download new Ol release and build it.
                  At the end it will generate run.sh file your basic tool to dealing with Ol.
      update  -   it will remove existing Ol instance, download the new one, build it etc.
      clean   -   it will remove local Ol's instance with all the files generated by Feather.
      install <gl>  -  where 'gl' mean git link. It will install package from git repo. 
  ";
  say($help);
}

sub open_feather_json {
  my ($path) = @_;
  # my $feather_string; 
  #{
  #  local $/ = undef;
    open(my $pf, "<", $path) or die "Package is not proper Feather package. Missing feather.json file";
    #   my $feather_string = <$pf>;
    # close $pf;
    #}
  my $feather_string = do { local $/; <$pf> };
  close $pf;

  my $feather_json = decode_json($feather_string); 
  return $feather_json;
}

sub get_package {
  my ($link) = @_;
  my @splitted_link = split(/\//, $link);
  my $package_name = $splitted_link[$#splitted_link];
  # Really naive aproach ...remove package to make a space for a new one
  rmtree "./libs/$package_name";
  my $response = system("cd ./libs && git clone --depth=1 --branch=master $link");
  if ($response == 0 and scalar(@splitted_link) > 0) {
    my %feather_json = open_feather_json("./libs/$package_name/feather.json");
    my @deps = %feather_json{"deps"};
    say("Known deps of package $package_name: @deps");
    if (scalar(@deps) > 0) {
      # Install deps of the deps
      foreach(@deps) {
        get_package($_);
      }
    }
    
    say("Package ", $package_name, " has been added into the libs");
    
  } else {
    say("Cannot install package from link: ", $link);
  }
}

sub install_package {
  my ($link) = @_;
  get_package($link);
}

sub install_packages {
  # Getting deps from feather.json
  if (not (-d "./libs")) {
    mkdir "./libs";
  }
  say("INSTALL PACKAGES");
  my $feather_json = open_feather_json("./feather.json");
  my @deps = @{$feather_json->{'deps'}};
  my $deps_size = scalar(@deps);
  if (scalar(@deps) > 0) {
   say(Dumper(@deps)); 
   for my $elem ( @deps ) {
    if ($elem) {
      get_package($elem);
    }
  }


  }
 }

sub test() {
  install_packages();
  my @errors = ();
  my $test_files_rule = File::Find::Rule->file->name("test_*.scm");
  my @test_files = File::Find::Rule->or($test_files_rule)->in(getcwd());

  my @test_files_names = map { 
    my @splitted = split("/", $_);
    $splitted[$#splitted];
  } @test_files;

  my @results = map { 
    say("\nTesting $_ ...");
    my ($stdout, $stderr) = tee { system("ol $_") };
    if ($stderr) {
      my @file_name_splitted = split("/", $_);
      my $file_name = $file_name_splitted[$#file_name_splitted];
      my @err_struct = ($file_name, $stderr);
      push(@errors, \@err_struct);
    }
    split ("\n" ,$stdout) } @test_files;

  my $files_tested_count = scalar @results;
  if (scalar(@errors) > 0) {
    say("\n----------ERRORS----------");
    foreach(@errors) {
      my @error = ($_);
      my $file_name = $error[0][0];
      my $err = $error[0][1];
      say("File: $file_name");
      say("Error MSG: $err");
      say("\n");
    }
  }

  my $errors_count = scalar(@errors);
  say("There were $files_tested_count test");
  say("There were Errors: $errors_count errors");
 # Test each file ...return summary with errors
}


sub parse_command {
  my ($command, @params) = (@_);
   given ($command) {
      when (/^init/) { install_ol() }
      when (/^installPackages/) { install_packages() }
      when (/^install/) { install_package(@params) }
      when (/^update/) { update_ol() }
      when (/^clean/) { clean_feather() }
      when (/^help/) { print_help() }
      when (/^test/) { test() }
      default { print_help() }
    } 
}

sub parse_argv {
  my @args = @_;
  if ((scalar @args) > 0) {
    parse_command(@args); 
  }
}

parse_argv(@ARGV);
